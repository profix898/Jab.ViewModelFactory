# Jab.ViewModelFactory ‚Äì Conceptual and Internal Design Documentation

This document outlines the **motivation**, **core concepts**, **design rationale**, and **technical implementation details** of the `Jab.ViewModelFactory` project. It is intended for contributors, advanced users, and library maintainers who wish to understand not just how to use the library, but how it works internally and why certain decisions were made.

---

## üìä Background and Motivation

### Jab in a Nutshell
[Jab](https://github.com/pakrym/jab) is a **compile-time dependency injection (DI) generator** for C#. It enables high-performance, zero-reflection DI by emitting all container logic at compile time. Unlike traditional DI frameworks (e.g., Autofac, Unity, or Microsoft.Extensions.DependencyInjection), Jab does **not rely on runtime reflection**, making it ideal for AOT scenarios and performance-critical applications.

### MVVM Patterns: ViewModel-First vs View-First
In most XAML-based UI frameworks (e.g., Avalonia, WPF, MAUI, WinUI), MVVM can be implemented in two primary ways:

- **ViewModel-first:** The application creates a ViewModel, and a runtime mechanism (like Avalonia's `ViewLocator`) is used to find and instantiate the corresponding View.
- **View-first:** The application (or navigation system) creates the View directly, and the View is responsible for obtaining its own ViewModel, usually through constructor injection or a factory.

### The Problem
In frameworks like **Avalonia**, the default templates use a **ViewModel-first** approach backed by a `ViewLocator` pattern:
- The `ViewLocator` inspects the type of the `DataContext` (i.e., the ViewModel),
- Uses naming conventions and **reflection** to locate and instantiate the corresponding View.

While convenient, this approach defeats the **core purpose of Jab**: avoiding runtime reflection and shifting dependency wiring to compile time.

### The Solution
`Jab.ViewModelFactory` bridges this gap by enabling a **view-first MVVM approach** that works **without any runtime reflection** and leverages Jab's compile-time guarantees. It does so by:

- Recognizing views that request their ViewModels via `Func<..., TViewModel>` constructor parameters.
- Generating factory methods to construct those ViewModels.
- Generating diagnostics and code fixes to auto-register the factories in the appropriate Jab container.

---

## üìê Core Concepts

### View Declares Its ViewModel as a Factory

Any `View` class that has a constructor like the following is supported:

```csharp
public class CustomerView : UserControl
{
    public CustomerView(Func<Guid, CustomerViewModel> factory)
    {
        DataContext = factory(Guid.NewGuid());
    }
}
```

This pattern implies:
- `Guid` is a runtime/custom parameter provided by the View at call time.
- Remaining ViewModel constructor parameters (e.g., `ILogger`, services) are DI-injected by Jab.
- The ViewModel constructor signature must have runtime parameters **first**, followed by injected services.

### Generator Emits ViewModel Factory

The generator emits a factory method into the Jab container/module that **returns a `Func` delegate**:

```csharp
public static System.Func<Guid, CustomerViewModel> CreateCustomerViewModel(IApi api, ILogger<CustomerViewModel> logger)
{
    return (Guid id) => new CustomerViewModel(id, api, logger);
}
```

Key points:
- The **ViewModel constructor** takes runtime/custom parameters (like `Guid`) **first**, followed by DI-injected services.
- The **factory method** receives only the DI-injected parameters from Jab.
- The **returned `Func` delegate** accepts the runtime/custom parameters and creates the ViewModel, combining both.
- This allows the View to provide runtime values (e.g., an ID) while Jab handles all service dependencies.

### Analyzer + CodeFix Automatically Add Registration

```csharp
[ServiceProvider]
[Transient<CustomerView>]
// Generated by CodeFix - registers the Func delegate, not the ViewModel directly:
[Transient<System.Func<Guid, CustomerViewModel>>(Factory = nameof(CreateCustomerViewModel))]
public partial class AppContainer { }
```

Note: The registration is for `Func<..., ViewModel>`, not the ViewModel type itself. This matches how Jab resolves factory delegates.

---

## ü§ñ Feature Set and Capabilities

### 1. Source Generator
- Detects all view classes with a `Func<..., TViewModel>` constructor parameter.
- Finds a matching ViewModel constructor.
- Splits ViewModel constructor parameters into:
  - **Runtime/custom args**: Types from `Func<T1, ..., TN, TViewModel>` (all type args except the last). These must be the **first** parameters of the ViewModel constructor.
  - **Injected args**: Remaining ViewModel constructor parameters (resolved by Jab at compile time).
- Emits a `Create{Vm}` factory method that captures DI services and **returns a `Func` delegate** for the View to invoke.

### 2. Analyzer
- **JVMF001**: Reports views with `Func<ViewModel>` parameters not registered in any provider.
- **JVMF002**: Reports missing `Func<ViewModel>` registrations when a view is registered without its ViewModel factory.
- **JVMF004**: Reports ambiguous ViewModel constructors when multiple match the runtime parameter prefix.
- Issues diagnostics with precise locations for IDE integration.

### 3. Code Fix Providers
- **AddViewModelRegistrationFixProvider** (for JVMF002)
  - Offers to insert `[Transient<Func<..., TVm>>(Factory = ...)]` immediately after `[Transient<View>]`.
  - Presents a dropdown of lifetime options (`Transient`, `Scoped`, `Singleton`).
  - Preserves or sorts attributes (configurable).

- **AddViewRegistrationFixProvider** (for JVMF001)
  - Offers to register the unregistered view in the nearest service provider.

- **InjectionConstructorFixProvider** (for JVMF004)
  - When multiple ctors are valid, offers to insert `[InjectionConstructor]` to disambiguate.

### 4. Multi-Container Support
- Works across multiple `[ServiceProvider]` and `[ServiceProviderModule]` classes.
- Factories are emitted only into containers where the view is registered.
- Code fixes pick the correct location automatically.

---

## üìÜ Design Decisions and Rationale

### ‚úÖ Use of `Func<..., TVm>`
Why use `Func<...>` instead of direct constructor injection?
- Supports **runtime arguments** (like `Guid`, strings, etc.).
- Matches common usage in Avalonia, where `Func` enables DataContext assignment.
- Avoids circular dependencies.

### ‚úÖ Register `Func<ViewModel>` Not `ViewModel`
Why does the code fix generate `[Transient<Func<ViewModel>>]` instead of `[Transient<ViewModel>]`?
- **Jab's factory pattern**: When you use `Factory = nameof(...)`, Jab expects the factory to return the registered service type.
- **Consistent with the view's expectation**: The view requests `Func<..., ViewModel>`, so we register that exact type.
- **Captures DI dependencies**: The factory method captures injected dependencies and returns a delegate that the view can invoke with runtime arguments.

### ‚úÖ Generate Into Containers and Modules
Both `[ServiceProvider]` and `[ServiceProviderModule]` classes can host generated factories.

- Containers usually represent the root app DI container.
- Modules are composable service registrations.

Treating both equally allows full flexibility.

### ‚úÖ Use of Constructor Prefix Matching
The ViewModel constructor parameters are split based on the `Func<...>` type arguments:
- **Runtime/custom args** (from the Func signature) must match the **first N parameters** of the constructor
- **Injected args** (DI services) are the remaining parameters

A constructor is valid **if** its first N parameters match the runtime types from the Func.

Example: For `Func<Guid, CustomerViewModel>`, the ViewModel constructor must start with a `Guid` parameter:
```csharp
public CustomerViewModel(Guid id, IApi api, ILogger logger) // ‚úÖ Valid: starts with Guid
public CustomerViewModel(IApi api, Guid id, ILogger logger) // ‚ùå Invalid: Guid not first
```

If multiple constructors match, `[InjectionConstructor]` is required to disambiguate.

### ‚úÖ Attribute Pairing and Sorting
The code fix tries to keep this nice:

```csharp
[Transient<CustomerView>, Transient<System.Func<Guid, CustomerViewModel>>(Factory = nameof(CreateCustomerViewModel))]
```

Or on separate lines:
```csharp
[Transient<CustomerView>]
[Transient<System.Func<Guid, CustomerViewModel>>(Factory = nameof(CreateCustomerViewModel))]
```

Optional attribute sorting keeps view/viewmodel pairs together and reorders unrelated attributes. Can be disabled via configuration.

---

## üì¢ Diagnostics Explained

| ID | Name | Description |
|----|------|-------------|
| **JVMF001** | View Not Registered | A view with a `Func<ViewModel>` constructor parameter is not registered in any `[ServiceProvider]` or `[ServiceProviderModule]`. |
| **JVMF002** | Missing ViewModel Registration | A view is registered but the corresponding `Func<..., ViewModel>` factory is not registered with a `Factory` argument. |
| **JVMF003** | No Matching Constructor | No public ViewModel constructor matches the runtime parameter prefix from the `Func<...>` signature. |
| **JVMF004** | Ambiguous Constructors | Multiple ViewModel constructors match the runtime parameter prefix. Add `[InjectionConstructor]` to disambiguate. |

---

## üìë Configuration

### Attribute Sorting
By default, code fixes sort attributes to pair view and viewmodel registrations.

Disable this by setting **either**:

#### In `.editorconfig`:
```ini
[*.cs]
build_property.Jab.ViewModelFactoryFix_SortAttributes = false
```

#### Or in `.csproj`:
```xml
<PropertyGroup>
  <Jab.ViewModelFactoryFix_SortAttributes>false</Jab.ViewModelFactoryFix_SortAttributes>
</PropertyGroup>
```

---

## üìè ViewLocator vs View-First with Jab

### Avalonia‚Äôs ViewLocator

In Avalonia:
- You bind `DataContext = new MyViewModel()`.
- A `ViewLocator` maps the ViewModel type (via naming convention) to a `UserControl` subclass.
- It then uses **reflection** to instantiate the View.

Pros:
- Simple and convention-based.
- Easy to use for small apps.

Cons:
- Relies on reflection.
- Fragile: typos only fail at runtime.
- Not compatible with Jab's compile-time philosophy.

### Jab.ViewModelFactory

This project replaces ViewLocator with:
- Compile-time factory generation.
- View-first composition.
- Full static analysis and validation.

Benefits:
- ‚úÖ Zero runtime reflection
- ‚úÖ Compile-time guarantees
- ‚úÖ Cleaner constructor-based composition

---

## üîÑ Future Improvements

- [ ] Support for custom delegate types (not just `Func<...>`)
- [ ] Factory naming customization
- [ ] More granular control over diagnostics (suppressions, severity)
- [ ] Extended validation for service lifetime mismatches

---

## üìä Summary

`Jab.ViewModelFactory` is a powerful extension to Jab that enables a **natural, safe, and efficient view-first MVVM workflow**. It:

- Eliminates runtime reflection.
- Maintains compile-time safety.
- Encourages declarative constructor-based wiring.
- Works seamlessly across Avalonia, WPF, WinUI, MAUI, and others.

By combining source generators, analyzers, and code fixes, it brings modern developer tooling to MVVM workflows that need more than what reflection-based systems can offer.

---

*Contributors welcome! This project is evolving. Please feel free to open issues, submit PRs, or provide feedback.*
